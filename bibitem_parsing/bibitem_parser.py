import re
import string
import subprocess
import sys

from bibitem_parsing.algorithmEnum import Algorithm


#import torch
#from sciwing.models.neural_parscit import NeuralParscit



class BibitemParser():
    """class for parsing bibitems in a file to author name tuples"""

    def __init__(self):
        self.php_convertion_script_file = "bibitem_parsing/php_script_tex2bib/index.php"
        # self.neural_parscit = NeuralParscit()

    def _strip_special_chars(self, unclean_string: str) -> str:
        """
        strips \newblock etc.
        example:
        input:
            \newblock {Video Jigsaw: Unsupervised Learning of Spatiotemporal Context for
              Video Action Recognition}.
        result:
            {Video Jigsaw: Unsupervised Learning of Spatiotemporal Context for
              Video Action Recognition
        ----------
        unclean_string : str
            the string that is to be cleaned
        """
        assert type(unclean_string) == str

        unclean_string = unclean_string.replace("\\n ", " ")
        unclean_string_split = re.split(r"\\\S+", unclean_string)
        if len(unclean_string_split) < 2:
            return unclean_string

        unclean_string = unclean_string_split[1].strip()
        return unclean_string

    def _strip_letter_encasing(self, unclean_string: str) -> str:
        """
        strips letter encasing of the form {a}
        can also handle {} and removes that altogether
        ----------
        unclean_string : str
            the string that is to be cleaned
        """
        assert type(unclean_string) == str
        occurrences = re.findall(r"{\S}|{}", unclean_string)
        for c in occurrences:
            if len(c) == 3:
                unclean_string = unclean_string.replace(c, c[1])
            if len(c) == 2:
                unclean_string = unclean_string.replace(c, '')
        return unclean_string.strip()

    def _strip_encasing_brackets(self, unclean_string: str) -> str:
        """
        strips the first { and last bracket }
        ----------
        unclean_string : str
            the string that is to be cleaned
        """
        assert type(unclean_string) == str
        if unclean_string == "":
            return ""

        if unclean_string[0] == "{":
            unclean_string = unclean_string[1:-1]

        if unclean_string == "":
            return ""

        if unclean_string[-1] == "}":
            if len(unclean_string) <= 2:
                return unclean_string
            unclean_string = unclean_string[0:-1]
            unclean_string = unclean_string.strip()

        return unclean_string

    def _strip_dangling_brackets_and_comma(self, unclean_string) -> str:

        if unclean_string == "":
            return ""

        if "}" in unclean_string:
            unclean_string = unclean_string.split("}")[0]

        if unclean_string == "":
            return ""

        if unclean_string[-1] == ",":
            if len(unclean_string) <= 2:
                return unclean_string
            unclean_string = unclean_string[0:-1]
        return unclean_string.strip()

    def _clean_string(self, unclean_string: str):
        """
        cleans the raw string that is output by the php script
        ----------
        unclean_string : str
            the string that is to be cleaned
        """
        assert type(unclean_string) == str
        # remove leading spaces
        unclean_string = unclean_string.strip()

        # remove everything after linebreak
        unclean_string = unclean_string.split("\n")[0]
        unclean_string = self._strip_special_chars(unclean_string)
        unclean_string = self._strip_letter_encasing(unclean_string)
        unclean_string = self._strip_encasing_brackets(unclean_string)
        unclean_string = self._strip_dangling_brackets_and_comma(unclean_string)

        return unclean_string

    def _convert_bibtexstring_2_author_title_tuple(self, bibtexstring):
        """
        Does cleanup work after the execution of the tex2bib script
        Parameters
        ----------
        bibtexstring : str
            the string that is generated by tex2bib
        """
        if len(bibtexstring) <= 7:
            return None, None
        if len(bibtexstring.split("title = {")) < 2:
            return None, None
        title = bibtexstring.split("title = {")[1].split("year = {")[0][0:-2]
        if len(bibtexstring.split("author = {")) < 2:
            return None, None
        author = bibtexstring.split("author = {")[1].split("title = {")[0][0:-2]

        title = self._clean_string(title)
        author = self._clean_string(author)

        unidentified = bibtexstring.split("unidentified = {")
        if len(unidentified) > 1:
            if title is None and unidentified is not None and unidentified != "":
                title = self._clean_string(unidentified[1])

        return author, title

    def _parse_bibentrys_manually(self, tex_input_file: str) -> list:
        """
        parses the bibitems manually
        should deal with missing newlines etc.
        returns

        Parameters
        ----------
        tex_input_file : str
            tex file with the bibitems that are to be converted
        """
        try:
            text_file = open(tex_input_file, "r")
            # read whole file to a string
            data = text_file.read()
            data = data.strip()
            # if bbl follows newblock syntax do own parsing
            # TODO add extra newblock parsing
            split = data.split("\\bibitem", 1)

            if (len(split) >= 2):
                data = "\\bibitem" + split[1]
            data = data.split("\n\n")
        except IsADirectoryError:
            data = tex_input_file + "could not be read"
            sys.stderr.write("Error message: Is a directory. \n")
            pass
        return data

    def convert_texfile_2_author_title_tuples(self, tex_input_file: bytes, algorithm: Algorithm):
        """
        Uses different librarys to get information from the citation strings:

        1. tex2bib: https://github.com/juusechec/tex2bib
        that is based on :https://text2bib.economics.utoronto.ca/index.php/index

        2.neuralparcite:  https://www.comp.nus.edu.sg/~kanmy/papers/neural-parscit-deep.pdf
        found in :https://github.com/abhinavkashyap/sciwing

        Parameters
        ----------
        :param tex_input_file: tex file with the bibitems that are to be converted
        :param algorithm:
        """

        if algorithm == Algorithm.Bib2Tex:
            try:
                result = subprocess.run(
                    ['php', self.php_convertion_script_file,
                    tex_input_file],  # program and arguments
                    text=True,
                    capture_output=True,
                    check=True  # raise exception if program fails
                )
                result_string: string = result.stdout
            except UnicodeDecodeError:
                result_string: str = ""
            citation_entry_strings = result_string.split("\n\n")
            author_title_tuples = list(map(self._convert_bibtexstring_2_author_title_tuple, citation_entry_strings))

        elif algorithm == Algorithm.NeuralParcite:
            data = self._parse_bibentrys_manually(tex_input_file=tex_input_file)
 #           author_title_tuples = []
 #           for dataitem in data:
                # testdata = testdata.replace("\\n", " ")
 #               dataitem = self._strip_letter_encasing(dataitem)
 #               dataitem = re.sub(r"({|}|\[|\])", " ", dataitem)
                #dataitem = self._strip_special_chars(dataitem)
  #              labels = self.neural_parscit.predict_for_text(dataitem,show=False)
   #             author_title_tuples.append(self._convert_neural_parscit_output_too_author_title_tuple(labels, dataitem))

        data = self._parse_bibentrys_manually(tex_input_file=tex_input_file)
        zipped_list = list(zip(author_title_tuples, data))
        return zipped_list

    def _convert_neural_parscit_output_too_author_title_tuple(self, labels, input_text):
        tuplelist = list(zip(labels.split(), input_text.split()))
        filteredtitlelist = list(filter(lambda x: x[0] == "title", tuplelist))
        filteredauthorlist = list(filter(lambda x: x[0] == "author", tuplelist))
        title = "".join(list(map(lambda x: x[1] + " ", filteredtitlelist))).strip()
        author = "".join(list(map(lambda x: x[1] + " ", filteredauthorlist))).strip()
        return author, title

    def check_how_many_titles_are_usable(self, author_title_tuple_list: list):
        """
        analyses  author_title_tuple_list and checks if the titles are actually usable
        TODO add more functionality not just check for None and empty string
        ----------
        author_title_tuple_list: list
            author_tuple_titles list that is to be analysed
        """
        all_count = len(author_title_tuple_list)
        accepted = 0
        cleaned_author_title_tuples = list()
        failed_author_title_tuples = list()
        for author_title_tuple in author_title_tuple_list:
            if author_title_tuple[0][1] != "" and author_title_tuple[0][1] is not None:
                accepted += 1
                cleaned_author_title_tuples.append(author_title_tuple)
            else:
                failed_author_title_tuples.append(author_title_tuple)

        return accepted, all_count, cleaned_author_title_tuples, failed_author_title_tuples


if __name__ == "__main__":
    tex_input_file = 'symperC.bbl'  # '/mnt/c/Users/sgoodall/Desktop/archive/NLPProjekt/bibitem_parsing/tex2bib-master/example-cites.tex'

    bibitemparser = BibitemParser()

    author_title_tuples = bibitemparser.convert_texfile_2_author_title_tuples(tex_input_file=tex_input_file,
                                                                              algorithm=Algorithm.NeuralParcite)
    for at in author_title_tuples:
        print("Author:", at[0][0])
        print("Title:", at[0][1])
        print("\n")
    print(bibitemparser.check_how_many_titles_are_usable(author_title_tuples))
