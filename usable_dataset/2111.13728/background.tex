
\section{Background}
In this section, we introduce the background for our work.
We summarize our key notations in Table~\ref{tab:notations}.
We do not cover the basics of quantum computing (e.g.,  density operator, unitary transformation) and recommend~\cite{nielsen2002quantum} for reference.

\begin{table}[b]
\caption{Notation used in this paper.}\label{tab:notations}
\resizebox{0.45\textwidth}{!}{
\begin{tabular}{p{0.2\linewidth} | p{0.75\linewidth}}
$q$, $\bar{q}$ & qubits, a set of qubits, respectively; \\\hline
$\ket{\psi}$, $\ket{\phi}$, $\ket{0}$, $\ket{1}$, $\ket{+}$, $\ket{-}$ & pure quantum states; \\\hline
$\rho$, $\ket{\psi}\bra{\psi}$ & density operators; \\\hline
$U$ & unitary transformations; \\\hline
$O, M$ & Observable; Use $M$ to stress measurement;\\\hline
$\mathcal{H}$ & the Hilbert space of quantum states;  \\\hline
$\mathcal{D(H)}$ & the set of partial density operators on $\mathcal{H}$; \\
\end{tabular} }
\end{table}

\subsection{Quantum Error Correction and Stabilizer}

Most QEC codes consist of three stages: encoding, decoding, and error correction. The encoding protocol projects an unprotected state of the data qubits into the subspace generated by the logical states. The decoding protocol detects potential errors by performing parity measurements on data qubits. Finally, the correction protocol removes the errors by driving the quantum state back to the logical subspace.



\noindent\textbf{Stabilizer}. 
The stabilizer formalism proposed by Gottesman~\cite{Gottesman1997StabilizerCA} provides a unifying description of many QEC codes. 
Given a $n$-qubit state $\ket{\psi}$ and a Pauli string $s \in \otimes^n \{I,X,Y,Z\}$, %
 we say that $s$ is a \textit{stabilizer} of $\ket{\psi}$, or $\ket{\psi}$ is \textit{stabilized} by $s$, if $s\ket{\psi} = \ket{\psi}$.
 When the stabilized state $\ket{\psi}$ is clear in the context, we will simply say that $s$ is a stabilizer, without referring to the stabilized state. 
We then can use multiple stabilizers to naturally identify a subspace, which is the intersection of the stabilizers' projection subspaces, to represent the logical states.
Moreover, stabilizers can also be observables and they can be measured to ascertain whether the state of the data qubits is in the correct subspace. 
These measurements are called \textbf{stabilizer measurements}. 
Another advantage of the stabilizer formalism is that it can describe standard quantum error channels on stabilized states.
Once the stabilizers are determined, the QEC encoding, decoding, and error correction can be easily derived.

Due to the centrality of stabilizers in QEC codes, including them as fundamental concepts of the verification framework is a promising direction. 
Benefiting from the expressiveness of the stabilizer formalism, we believe that our verification framework for quantum stabilizer codes will be applicable to many existing QEC codes and will help designing novel implementations of fault-tolerant operations. 

In the writing time of this paper, we also notice that Rand, Sundaram, Singhal and Lackey~\cite{Rand2021StaticAO, Rand2021ExtendingGT, Rand2021GottesmanTF} develop an elegant type-checking system for 
general quantum programs based on the stabilizer formalism. %
Despite that we share same high-level insights in utilizing stabilizer formalism~\cite{Gottesman1997StabilizerCA}, we differ significantly in the overall optimization goal and the entire design framework. 
In addition, their work only consider quantum circuits and cannot deal with branch statements (e.g., if and while). 
These statements are indispensable for QEC programs. 
In contrast, we can handle branch statements by incorporating stabilizer variables in the design of quantum predicate logic. Last but not least, this paper also develops a compact language for QEC programs while their work follows the vanilla quantum circuit language~\cite{nielsen2002quantum}.








\subsection{Quantum Program Language}
The {\qwhilelang} proposed by Ying~\cite{Ying2012FloydhoareLF} provides a universal description of purely-quantum programs without classical variables. It focuses on characterizing basic quantum program structures
and its syntax is defined in Backus-Naur form as follows:


%
\begin{tcolorbox}[colback=yellow!10!white,
                  colframe=white!20!black]
\begin{grammar}
%  
\label{equ:qwhile}
  \let\syntleft\relax
  \let\syntright\relax
%
<$\prog$> $\Coloneqq$ \textbf{skip}
\vsep $q \coloneqq \qstate{0}$
\vsep $\bar{q} \coloneqq U[\bar{q}]$
\vsep $\prog_1;\prog_2$
\alt $\textbf{case}\ M[\bar{q}] = \overline{m \to \prog_m}\ \textbf{end}$
\alt $\textbf{while}\  M[\bar{q}]=1\ \textbf{do}\ \prog_1\ \textbf{done}$
%
\end{grammar}
\end{tcolorbox}
%
Here $\prog$ plays the role of a statement of the {\qwhilelang}, but can also indicates the full program when seen as a sequence of statements. In the expressions above, $q$ denotes a quantum variable and $\bar{q}$ represents a quantum register associated with a finite number of quantum variables. The language constructs above are explained as follows: 
\setcounter{cnt}{0}
(\showcnt)  \textbf{skip} does nothing; 
(\showcnt) $q \coloneqq \qstate{0}$ prepare quantum variable $q$ in state $\qstate{0}$; 
(\showcnt) $\bar{q} \coloneqq U[\bar{q}]$ perform unitary operation $U$ on the quantum registers $\bar{q}$; 
(\showcnt) $\prog_1;\prog_2$ is the sequencing of statements; 
(\showcnt) $\textbf{case}\ M[\bar{q}] = \overline{m \to \prog_m}\ \textbf{end}$ measures the quantum variables in $\bar{q}$ with semi-positive Hermitian operators $M=\{M_0,M_1, \cdots, M_m\}$ and executes program $\prog_m$ if the measurement outcome is $m$; 
(\showcnt) $\textbf{while} \; M[\bar{q}]=1\ \textbf{do}\ \prog_1\ \textbf{done}$ measures qubits $\bar{q}$ and executes $\prog_1$ if the measurement outcome is 1. If the measurement outcome is 0, the while loop terminates. Here $M$ is assumed to have only two possible outcomes, $m=0,1$.

The semantics of {\qwhilelang} is developed by assuming partial density operators as quantum program states. 
The details  can be found in ~\cite{Ying2012FloydhoareLF}.

%
\subsection{Quantum Hoare Logic and Quantum Predicates}
\textit{Quantum Hoare logic}~\cite{Ying2012FloydhoareLF} provides a syntax-directed proof system for reasoning about quantum program correctness. The basic computing unit of quantum Hoare logic is the \textit{Hoare tripe}, which is in the form of $\{A\}\prog\{B\}$. Here $A$ and $B$ are \textit{quantum predicates}, $\prog$ is the quantum program. $A$ is often called \textit{precondition} while $B$ is called \textit{post-condition}. The general meaning of the quantum Hoare tripe is that, if the input state satisfies $A$, then the output state of $\prog$ satisfies $B$. The exact mathematical interpretation of the quantum Hoare tripe depends on the type of the predicates used.

 
A general quantum predicate is a Hermitian operator $O$~\cite{Ying2012FloydhoareLF} where $0 \le Tr(O\rho) \le 1, \forall \rho \in \mathcal{D(H)}$. %
A quantum state $\rho$ satisfies the quantum predicate $O$ depending on the value of $Tr(O\rho)$, which represents the expectation value of $O$ on state $\rho$. 
In practice, measuring $Tr(O\rho)$ can be very time-consuming . 
This can be avoided by restricting the predicate from a general Hermitian operator to a projection operator $\projector$ with the property that $\projector^2 = I$.
We say that a quantum state $\rho$ satisfies predicate $\projector$ (denoted by $\rho \models \projector$) if $\projector\rho = \rho$. %
A projection operator $\projector$ can also be described by its subspace with eigenvalue +1, namely $S_{\projector}= \{ \ket{\psi} s.t. \ket{\psi} = \projector\ket{\psi} \}$ in the qubits' Hilbert space $\mathcal{H}$. Birkhoff and Neumann~\cite{Birkhoff1936TheLO} define a quantum logic on the set of subspaces in $\mathcal{H}$ in which, for example, the logical {\bf and} corresponds to the intersection of subspaces. This construction induces logic operations %
on projection operators by considering the equivalent operation on the associated subspaces.





