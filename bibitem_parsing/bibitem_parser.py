import re
import string
import subprocess


class BibitemParser():
    """class for parsing bibitems in a file to author name tuples"""

    def __init__(self, php_convertion_script_file):
        self.php_convertion_script_file = php_convertion_script_file

    def _strip_special_chars(self, unclean_string: str) -> str:
        """
        strips \newblock etc.
        example:
        input:
            \newblock {Video Jigsaw: Unsupervised Learning of Spatiotemporal Context for
              Video Action Recognition}.
        result:
            {Video Jigsaw: Unsupervised Learning of Spatiotemporal Context for
              Video Action Recognition
        ----------
        unclean_string : str
            the string that is to be cleaned
        """
        assert type(unclean_string) == str

        unclean_string_split = re.split(r"\\\S+", unclean_string)
        if len(unclean_string_split) < 2:
            return unclean_string

        unclean_string = unclean_string_split[1].strip()
        return unclean_string

    def _strip_letter_encasing(self, unclean_string: str) -> str:
        """
        strips letter encasing of the form {a}
        can also handle {} and removes that altogether
        ----------
        unclean_string : str
            the string that is to be cleaned
        """
        assert type(unclean_string) == str
        occurrences = re.findall(r"{\S}|{}", unclean_string)
        for c in occurrences:
            if len(c) == 3:
                unclean_string = unclean_string.replace(c, c[1])
            if len(c) == 2:
                unclean_string = unclean_string.replace(c, '')
        return unclean_string.strip()

    def _strip_encasing_brackets(self, unclean_string: str) -> str:
        """
        strips the first { and last bracket }
        ----------
        unclean_string : str
            the string that is to be cleaned
        """
        assert type(unclean_string) == str
        if unclean_string == "":
            return ""

        if unclean_string[0] == "{":
            unclean_string = unclean_string[1:-1]

        if unclean_string == "":
            return ""

        if unclean_string[-1] == "}":
            if len(unclean_string) <= 2:
                return unclean_string
            unclean_string = unclean_string[0:-1]
            unclean_string = unclean_string.strip()

        return unclean_string

    def _strip_dangling_brackets_and_comma(self, unclean_string) -> str:

        if unclean_string == "":
            return ""

        if "}" in unclean_string:
            unclean_string = unclean_string.split("}")[0]

        if unclean_string == "":
            return ""

        if unclean_string[-1] == ",":
            if len(unclean_string) <= 2:
                return unclean_string
            unclean_string = unclean_string[0:-1]
        return unclean_string.strip()

    def _clean_string(self, unclean_string: str):
        """
        cleans the raw string that is output by the php script
        ----------
        unclean_string : str
            the string that is to be cleaned
        """
        assert type(unclean_string) == str
        # remove leading spaces
        unclean_string = unclean_string.strip()

        # remove everything after linebreak
        unclean_string = unclean_string.split("\n")[0]
        unclean_string = self._strip_special_chars(unclean_string)
        unclean_string = self._strip_letter_encasing(unclean_string)
        unclean_string = self._strip_encasing_brackets(unclean_string)
        unclean_string = self._strip_dangling_brackets_and_comma(unclean_string)

        return unclean_string

    def _convert_bibtexstring_2_author_title_tuple(self, bibtexstring):
        """
        Does cleanup work after the execution of the tex2bib script
        Parameters
        ----------
        bibtexstring : str
            the string that is generated by tex2bib
        """
        if len(bibtexstring) <= 7:
            return None, None
        if len(bibtexstring.split("title = {")) < 2:
            return None, None
        title = bibtexstring.split("title = {")[1].split("year = {")[0][0:-2]
        if len(bibtexstring.split("author = {")) < 2:
            return None, None
        author = bibtexstring.split("author = {")[1].split("title = {")[0][0:-2]

        title = self._clean_string(title)
        author = self._clean_string(author)

        unidentified = bibtexstring.split("unidentified = {")
        if len(unidentified) > 1:
            if title is None and unidentified is not None and unidentified != "":
                title = self._clean_string(unidentified[1])

        return author, title

    def _parse_bibentrys_manually(self, tex_input_file: str) -> list:
        """
        parses the bibitems manually
        should deal with missing newlines etc.
        returns

        Parameters
        ----------
        tex_input_file : str
            tex file with the bibitems that are to be converted
        """
        text_file = open(tex_input_file, "r")

        # read whole file to a string
        data = text_file.read()
        data = data.strip()
        # if bbl follows newblock syntax do own parsing
        # TODO add extra newblock parsing
        split = data.split("\\bibitem", 1)

        if (len(split) >= 2):
            data = "\\bibitem" + split[1]
        data = data.split("\n\n")
        if "\\newblock" in data:
            print("DATALEN", len(data))

        return data

    def convert_texfile_2_author_title_tuples(self, tex_input_file):
        """
        Uses this Bib 2 convert tex2bib: https://github.com/juusechec/tex2bib
        that is based on :https://text2bib.economics.utoronto.ca/index.php/index
        Parameters
        ----------
        tex_input_file : str
            tex file with the bibitems that are to be converted
        """

        result = subprocess.run(
            ['php', self.php_convertion_script_file,
             tex_input_file],  # program and arguments
            text=True,
            capture_output=True,
            check=True  # raise exception if program fails
        )
        result_string: string = result.stdout
        citation_entry_strings = result_string.split("\n\n")
        author_title_tuples = list(map(self._convert_bibtexstring_2_author_title_tuple, citation_entry_strings))
        data = self._parse_bibentrys_manually(tex_input_file=tex_input_file)
        zipped_list = list(zip(author_title_tuples, data))
        return zipped_list

    def check_how_many_titles_are_usable(self, author_title_tuple_list: list):
        """
        analyses  author_title_tuple_list and checks if the titles are actually usable
        TODO add more functionality not just check for None and empty string
        ----------
        author_title_tuple_list: list
            author_tuple_titles list that is to be analysed
        """
        all_count = len(author_title_tuple_list)
        accepted = 0
        cleaned_author_title_tuples = list()
        failed_author_title_tuples = list()
        for author_title_tuple in author_title_tuple_list:
            if author_title_tuple[0][1] != "" and author_title_tuple[0][1] is not None:
                accepted += 1
                cleaned_author_title_tuples.append(author_title_tuple)
            else:
                failed_author_title_tuples.append(author_title_tuple)

        return accepted, all_count, cleaned_author_title_tuples, failed_author_title_tuples


if __name__ == "__main__":
    tex_input_file = '/mnt/c/Users/sgoodall/Desktop/archive/NLPProjekt/bibitem_parsing/tex2bib-master/ss_det.bbl'  # '/mnt/c/Users/sgoodall/Desktop/archive/NLPProjekt/bibitem_parsing/tex2bib-master/example-cites.tex'
    php_convertion_script_file = '/mnt/c/Users/sgoodall/Desktop/archive/NLPProjekt/bibitem_parsing/tex2bib-master/index.php'

    bibitemparser = BibitemParser(php_convertion_script_file)

    author_title_tuples = bibitemparser.convert_texfile_2_author_title_tuples(tex_input_file=tex_input_file)
    for at in author_title_tuples:
        print("Author:", at[0])
        print("Title:", at[1])
        print("\n")
    print(bibitemparser.check_how_many_titles_are_usable(author_title_tuples))
